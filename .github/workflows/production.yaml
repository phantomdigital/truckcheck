name: Deploy Migrations to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      # DEPLOYMENT STRATEGY: Build → Migrate → Deploy
      #
      # Failure scenarios and handling:
      # 1. Build fails → Stop (no migrations, no deploy) Safe
      # 2. Migrations fail → Stop (no deploy, DB unchanged) Safe  
      # 3. Deploy fails → Migrations already applied Requires backward-compatible migrations
      #
      # BEST PRACTICE: Make migrations backward-compatible (additive only)
      # - Add new columns/tables (don't remove until next release)
      # - Add new indexes (safe)
      # - Don't drop columns/tables in same release as code that uses them
      # - Use nullable columns or defaults when adding required fields
      #
      # This ensures old code continues working if deploy fails after migrations succeed
      
      # Build the code first to catch build errors before pushing migrations
      # This prevents database schema changes if the code won't compile
      - name: Build Next.js application
        run: |
          npm ci
          npm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          # Add other required env vars for build if needed

      - name: Link to Supabase project
        if: success() # Only link if build succeeded
        run: |
          # Note: Supabase CLI uses Session mode pooler (port 5432) by default
          # Session mode has connection limits based on pool_size, even on Pro plan
          # The CLI may open multiple connections during link, hitting these limits
          # Solution: Retry with exponential backoff to allow connections to close
          
          # Small initial delay to avoid immediate connection spikes
          echo "Waiting 5 seconds before first connection attempt..."
          sleep 5
          
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo ""
            echo "=== Attempt $attempt of $max_attempts ==="
            echo "Linking to Supabase project..."
            
            if supabase link --project-ref $PROJECT_ID --password $SUPABASE_DB_PASSWORD --debug; then
              echo "Successfully linked to Supabase project"
              exit 0
            else
              if [ $attempt -lt $max_attempts ]; then
                # Exponential backoff: 20s, 40s, 60s, 80s
                wait_time=$((20 * attempt))
                echo ""
                echo "Link failed (likely Session mode connection limit)"
                echo "Waiting ${wait_time} seconds before retry..."
                echo "This allows Session mode pooler connections to close"
                sleep $wait_time
              else
                echo ""
                echo "Failed to link after $max_attempts attempts"
                echo ""
                echo "Possible causes:"
                echo "1. Session mode pooler connection limit reached (pool_size)"
                echo "2. Multiple concurrent connections from CLI"
                echo "3. Other processes using database connections"
                echo ""
                echo "Troubleshooting steps:"
                echo "1. Verify PRODUCTION_PROJECT_ID is correct"
                echo "2. Verify PRODUCTION_DB_PASSWORD is correct"
                echo "3. Ensure SUPABASE_ACCESS_TOKEN has correct permissions"
                echo "4. Check if project is paused in Supabase dashboard"
                echo "5. Check Supabase dashboard for active connections"
                echo "6. Consider contacting Supabase support to increase pool_size"
                echo "7. Review debug output above for specific errors"
                exit 1
              fi
              attempt=$((attempt + 1))
            fi
          done
        env:
          PROJECT_ID: ${{ secrets.PRODUCTION_PROJECT_ID }}
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}

      # Push migrations only if build succeeded
      # IMPORTANT: Migrations should be backward-compatible so old code still works
      # if this step succeeds but deployment fails
      - name: Push database migrations
        if: success() # Only push migrations if build and link succeeded
        run: supabase db push --include-all
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      # Deploy to Vercel only after migrations succeed
      # If this fails, migrations are already applied - ensure they're backward-compatible!
      # Old code should continue working with the new schema until next successful deploy
      - name: Deploy to Vercel (Production)
        if: success() # Only deploy if migrations succeed
        timeout-minutes: 10 # Prevent hanging on inspect step
        run: |
          npx vercel@latest deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --scope=${{ secrets.VERCEL_ORG_ID }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PRODUCTION_PROJECT_ID }}
        continue-on-error: true # Continue even if inspect step fails (deployment already succeeded)

