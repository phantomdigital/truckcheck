# TruckCheck Project Rules
# These rules ensure code quality, consistency, and maintainability

## TypeScript Rules

typescript:
  strict_types:
    - Never use `as any` - always create proper type definitions or interfaces
    - Never use `@ts-ignore` or `@ts-expect-error` without a detailed comment explaining why
    - Avoid using `any` type - use `unknown` if the type is truly unknown, then narrow it with type guards
    - Always explicitly type function return values for public functions
    - Use strict null checks - handle null and undefined explicitly
    - Prefer interfaces over types for object shapes (unless using unions/intersections)
  
  type_definitions:
    - Create dedicated type/interface files when types are shared across multiple files
    - Export types from a central location when used across the application
    - Use discriminated unions for complex state management
    - Always define proper types for component props, never use implicit any
  
  imports:
    - Use type-only imports when importing types: `import type { ... }`
    - Keep imports organized: React first, then third-party, then local imports
    - Use path aliases (@/) for cleaner imports

## React & Next.js Rules

react:
  components:
    - Server components by default - only add "use client" when necessary
    - If a server component needs client functionality, create a separate kebab-case client component file in the same folder and import it
    - Never use 'export *' in client boundaries - always use named exports
    - Component file names should match the component name (PascalCase for components, kebab-case for utilities)
    - Keep components focused and single-responsibility
  
  client_components:
    - Use "use client" directive only at the top of files that need client-side features
    - Client components should be in separate files from server components
    - Follow kebab-case naming for client component files that are imported by server components
    - Example: header.tsx (server) imports header-button.tsx (client)
  
  state_management:
    - Use functional setState updates when new state depends on previous state
    - Example: `setItems(prevItems => [...prevItems, newItem])` instead of `setItems([...items, newItem])`
    - Prevents stale closure issues
    - Use Context for shared state that needs to be accessed by multiple components
  
  hooks:
    - Always include proper dependencies in useEffect, useMemo, useCallback
    - Extract complex logic into custom hooks
    - Follow the "use" naming convention for custom hooks
  
  data_loading:
    - Data must be loaded on the server first, then on the client
    - No wrapper components for data loading - keep loading logic explicit

## Styling Rules

styling:
  tailwind:
    - Use Tailwind CSS utility classes for all styling
    - Follow the standard container pattern: `w-full max-w-[100rem] mx-auto px-4 lg:px-8`
    - Ensures consistent alignment with header across all page sections
    - Provides 1600px maximum width, responsive padding (16px mobile, 32px desktop)
    - Centers content on larger screens
  
  components:
    - Use shadcn/ui components for all UI elements (buttons, inputs, cards, dialogs, etc.)
    - Customize shadcn/ui components by modifying the component files, not with wrapper components
    - Keep consistent border opacity: use `border-border/50` for subtle borders in dark mode
    - Use semantic color tokens (primary, secondary, destructive, muted) not hard-coded colors

## Code Quality Rules

code_quality:
  logging:
    - Only use console.log, console.warn, console.error in development
    - Never commit production code with debug console statements
    - Use proper error handling instead of console.error in production
    - Consider using a logging library for production error tracking
  
  error_handling:
    - Always handle errors gracefully with user-friendly messages
    - Use try-catch blocks for async operations
    - Provide fallback UI for error states
    - Never expose technical error details to end users
  
  performance:
    - Lazy load components that aren't needed immediately
    - Optimize images using Next.js Image component
    - Minimize client-side JavaScript - prefer server components
    - Use React.memo() sparingly and only when profiling shows benefit
  
  accessibility:
    - Always include proper ARIA labels for interactive elements
    - Ensure keyboard navigation works for all interactive components
    - Use semantic HTML elements
    - Provide alt text for images
    - Ensure sufficient color contrast

## API & External Services

api:
  environment_variables:
    - All API keys and secrets must use environment variables
    - Prefix public env vars with NEXT_PUBLIC_ (e.g., NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN)
    - Never commit .env files to version control
    - Document all required environment variables in README
  
  error_handling:
    - Always handle API failures gracefully
    - Provide retry logic for transient failures
    - Show user-friendly error messages
    - Log API errors for debugging (development only)
  
  rate_limiting:
    - Implement debouncing for user input that triggers API calls (e.g., autocomplete)
    - Cache API responses when appropriate
    - Respect API rate limits

## File Organization

organization:
  structure:
    - Place shared components in /components
    - Place feature-specific components in /components/[feature-name]
    - Place utilities in /lib
    - Place types in /lib/[feature-name]/types.ts or at the component level
    - Use barrel exports (index.ts) to simplify imports from feature folders
  
  naming:
    - Components: PascalCase (e.g., LogbookChecker.tsx)
    - Utilities: camelCase (e.g., calculateDistance.ts)
    - Client components imported by servers: kebab-case (e.g., header-button.tsx)
    - Types/Interfaces: PascalCase (e.g., GeocodeResult)
    - Constants: UPPER_SNAKE_CASE (e.g., MAX_DISTANCE_KM)
  
  imports_exports:
    - Use named exports over default exports for better refactoring
    - Create index.ts files for cleaner imports from feature folders
    - Keep imports organized and remove unused imports

## Git & Version Control

git:
  commits:
    - Write clear, descriptive commit messages
    - Use conventional commits format: feat:, fix:, docs:, style:, refactor:, test:, chore:
    - Keep commits focused on a single change
  
  branches:
    - Never force push to main/master
    - Use descriptive branch names
    - Delete branches after merging
  
  hooks:
    - Never skip git hooks (--no-verify) unless absolutely necessary
    - Always run linting and type checking before committing

## Documentation

documentation:
  code_comments:
    - Write comments for complex logic, not obvious code
    - Use JSDoc comments for public functions and components
    - Explain "why" not "what" in comments
  
  readme:
    - Keep README up to date with setup instructions
    - Document all environment variables
    - Include examples for common use cases
  
  types:
    - Well-named types serve as documentation
    - Add comments to explain non-obvious type constraints

## Testing (Future)

testing:
  approach:
    - Write tests for critical business logic
    - Test user interactions, not implementation details
    - Use React Testing Library for component tests
    - Mock external API calls in tests

## Language & Localization

language:
  spelling:
    - Use Australian English spelling throughout the codebase
    - Examples: "travelling" not "traveling", "colour" not "color"
    - Use Australian terminology (e.g., "logbook" not "log book")
  
  formatting:
    - Use Australian date formats (DD/MM/YYYY)
    - Use metric units (km, not miles)
    - Use Australian address formats

## Project-Specific Rules

project_specific:
  nhvr_regulations:
    - Logbook required when travelling more than 100km from base
    - Base this on maximum distance from base along the driving route, not just straight-line distance to destination
    - Always include disclaimers that this tool is for reference only
  
  mapbox:
    - Always set preserveDrawingBuffer: true on map instances (required for PDF/print capture)
    - Store map instances properly for external access when needed
    - Reset map to original bounds before PDF capture
  
  user_data:
    - Store recent searches in localStorage only (no server-side storage yet)
    - Keep URL parameters shareable and bookmarkable
    - Never store sensitive information in URLs or localStorage

## Stripe & Subscriptions

stripe:
  data_fetching:
    - ALWAYS fetch subscription status and calculation history in Server Components (page.tsx)
    - NEVER fetch subscription data in client components - pass as props instead
    - Use Server Actions (getSubscriptionStatus, getCalculationHistory) only in Server Components
    - Pass subscription status (isPro) as props from page.tsx to client components
    - Use revalidatePath() after mutations to ensure fresh data on next render
  
  server_components:
    - Fetch all data at the page level (page.tsx) before rendering client components
    - Server Actions should only be called from Server Components for data fetching
    - Pass fetched data as props to client components - never fetch in client components
  
  mutations:
    - Client components can call Server Actions directly for mutations
    - Server Actions are designed to be called from client components (they have "use server" directive)
    - This is simpler and more type-safe than using API routes
    - Pattern: Server Components fetch data, Client Components call Server Actions for mutations
  
  feature_gating:
    - Gate features by passing isPro prop from Server Components (page.tsx)
    - Show upgrade prompts when free users try to access Pro features
    - Disable Pro features for free users with clear messaging
    - ALL Pro features MUST call validation Server Actions before executing:
      * Multiple Stops: call validateMultipleStops() before addStop()
      * CSV Import: call validateCSVImport() before processing CSV
      * PDF Export: call validatePDFExport() before generating PDF
    - Validation pattern for client components:
      ```typescript
      const handleFeature = async () => {
        const validation = await validateFeature()
        if (!validation.success) {
          toast.error(validation.error)
          return
        }
        // Feature logic here
      }
      ```
  
  calculation_history:
    - Only save calculation history for Pro users
    - Silently fail history saving - don't block UI if it fails
    - Use revalidatePath() after saving/deleting calculations
  
  security:
    - MANDATORY: All Pro features must have server-side validation before use
    - Three layers of security (defense in depth):
      1. Client-side checks (isPro prop) - UX only, NOT security
      2. Server Actions validation - validate subscription BEFORE executing feature
      3. Database RLS policies - enforce subscription at database level (for persisted data)
    - Pattern for client-side Pro features (CSV, PDF, Multiple Stops):
      * Client component calls validation Server Action
      * If validation passes, client-side processing proceeds
      * If validation fails, show error and return
    - Pattern for server-persisted Pro features (History, Recent Searches):
      * Client component calls Server Action
      * Server Action validates subscription status
      * Database RLS policy provides final enforcement
    - ALWAYS validate Pro subscription status server-side in Server Actions
    - Never trust client-side data - validate everything on the server
    - Verify user owns the data they're trying to access/modify
    - RLS policies check subscription_status in users table before allowing operations
    - See STRIPE_SECURITY.md for detailed security model
  
  ads:
    - Ad display is controlled by isPro prop from Server Component
    - Server Component (page.tsx) calls getSubscriptionStatus() which queries database
    - Ad components only rendered server-side if user is not Pro
    - User cannot bypass this - isPro comes from server-side database query
    - No RLS needed - ads are 3rd-party JavaScript, not database operations
    - Security: Server decides whether to include ad code in HTML, not client
  
  webhooks:
    - Handle all Stripe webhook events in /api/stripe/webhook route
    - Update user subscription status in Supabase on subscription events
    - Use metadata to link Stripe subscriptions to Supabase users

