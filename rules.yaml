# TruckCheck Project Rules
# These rules ensure code quality, consistency, and maintainability

## TypeScript Rules

typescript:
  strict_types:
    - Never use `as any` - always create proper type definitions or interfaces
    - Never use `@ts-ignore` or `@ts-expect-error` without a detailed comment explaining why
    - Avoid using `any` type - use `unknown` if the type is truly unknown, then narrow it with type guards
    - Always explicitly type function return values for public functions
    - Use strict null checks - handle null and undefined explicitly
    - Prefer interfaces over types for object shapes (unless using unions/intersections)
  
  type_definitions:
    - Create dedicated type/interface files when types are shared across multiple files
    - Export types from a central location when used across the application
    - Use discriminated unions for complex state management
    - Always define proper types for component props, never use implicit any
  
  imports:
    - Use type-only imports when importing types: `import type { ... }`
    - Keep imports organized: React first, then third-party, then local imports
    - Use path aliases (@/) for cleaner imports

## React & Next.js Rules

react:
  components:
    - Server components by default - only add "use client" when necessary
    - If a server component needs client functionality, create a separate kebab-case client component file in the same folder and import it
    - Never use 'export *' in client boundaries - always use named exports
    - Component file names should match the component name (PascalCase for components, kebab-case for utilities)
    - Keep components focused and single-responsibility
  
  client_components:
    - Use "use client" directive only at the top of files that need client-side features
    - Client components should be in separate files from server components
    - Follow kebab-case naming for client component files that are imported by server components
    - Example: header.tsx (server) imports header-button.tsx (client)
  
  state_management:
    - Use functional setState updates when new state depends on previous state
    - Example: `setItems(prevItems => [...prevItems, newItem])` instead of `setItems([...items, newItem])`
    - Prevents stale closure issues
    - Use Context for shared state that needs to be accessed by multiple components
  
  hooks:
    - Always include proper dependencies in useEffect, useMemo, useCallback
    - Extract complex logic into custom hooks
    - Follow the "use" naming convention for custom hooks
  
  data_loading:
    - Data must be loaded on the server first, then on the client
    - No wrapper components for data loading - keep loading logic explicit

  skeleton_loading:
    - ALWAYS use Suspense boundaries with skeleton loaders for dynamic server component data
    - Static content (titles, descriptions, headers) should render immediately outside Suspense
    - Dynamic content (data fetching) should be wrapped in Suspense with appropriate skeleton fallbacks
    - Pattern: Extract data-fetching components into separate server components, wrap in Suspense
    - Create skeleton components that match the structure of the actual components
    - Place skeleton components in the same folder as the components they represent (e.g., components/account/account-skeletons.tsx)
    - Benefits: Better perceived performance, progressive loading, improved UX
    - Apply to: Account pages, pricing pages, checkout success pages, any page with database queries
  
  page_structure:
    - Page components should be async Server Components by default
    - Separate static content (headers, titles, descriptions) into separate components or render directly
    - Keep static content outside Suspense boundaries for immediate rendering
    - Wrap all data-fetching components in Suspense boundaries with skeleton fallbacks
    - Pattern for pages with static headers:
      ```tsx
      // Static header component (can be separate or inline)
      function PageHeader() {
        return (
          <header>
            <h1>Page Title</h1>
            <p>Description</p>
          </header>
        )
      }
      
      // Main page component - async Server Component
      export default async function Page() {
        // Auth check for protected pages (if needed)
        // const user = await getCachedUser()
        // if (!user) redirect("/auth/login")
        
        return (
          <>
            {/* Static content - renders immediately */}
            <PageHeader />
            
            {/* Dynamic content - shows skeleton while loading */}
            <Suspense fallback={<ContentSkeleton />}>
              <DynamicContent />
            </Suspense>
          </>
        )
      }
      ```
    - For protected routes: Check auth at page level using getCachedUser(), redirect if unauthorized
    - For public routes: No auth check needed, but subscription status can still be fetched for feature gating
    - Use React cache() for getCachedUser() and getSubscriptionStatus() to avoid duplicate queries

## Styling Rules

styling:
  tailwind:
    - Use Tailwind CSS utility classes for all styling
    - Follow the standard container pattern: `w-full max-w-[100rem] mx-auto px-4 lg:px-8`
    - Ensures consistent alignment with header across all page sections
    - Provides 1600px maximum width, responsive padding (16px mobile, 32px desktop)
    - Centers content on larger screens
  
  components:
    - Use shadcn/ui components for all UI elements (buttons, inputs, cards, dialogs, etc.)
    - Customize shadcn/ui components by modifying the component files, not with wrapper components
    - Keep consistent border opacity: use `border-border/50` for subtle borders in dark mode
    - Use semantic color tokens (primary, secondary, destructive, muted) not hard-coded colors

## Code Quality Rules

code_quality:
  logging:
    - Only use console.log, console.warn, console.error in development
    - Never commit production code with debug console statements
    - Use proper error handling instead of console.error in production
    - Consider using a logging library for production error tracking
  
  error_handling:
    - Always handle errors gracefully with user-friendly messages
    - Use try-catch blocks for async operations
    - Provide fallback UI for error states
    - Never expose technical error details to end users
  
  performance:
    - Lazy load components that aren't needed immediately
    - Optimize images using Next.js Image component
    - Minimize client-side JavaScript - prefer server components
    - Use React.memo() sparingly and only when profiling shows benefit
    - Use React cache() to deduplicate database queries within the same render cycle
    - Wrap dynamic server components in Suspense boundaries with skeleton loaders
    - Keep static content (titles, descriptions) outside Suspense for immediate rendering
  
  accessibility:
    - Always include proper ARIA labels for interactive elements
    - Ensure keyboard navigation works for all interactive components
    - Use semantic HTML elements
    - Provide alt text for images
    - Ensure sufficient color contrast

## API & External Services

api:
  environment_variables:
    - All API keys and secrets must use environment variables
    - Prefix public env vars with NEXT_PUBLIC_ (e.g., NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN)
    - Never commit .env files to version control
    - Document all required environment variables in README
  
  error_handling:
    - Always handle API failures gracefully
    - Provide retry logic for transient failures
    - Show user-friendly error messages
    - Log API errors for debugging (development only)
  
  rate_limiting:
    - Implement debouncing for user input that triggers API calls (e.g., autocomplete)
    - Cache API responses when appropriate
    - Respect API rate limits

## File Organization

organization:
  structure:
    - Place shared components in /components
    - Place feature-specific components in /components/[feature-name]
    - Place utilities in /lib
    - Place types in /lib/[feature-name]/types.ts or at the component level
    - Use barrel exports (index.ts) to simplify imports from feature folders
  
  naming:
    - Components: PascalCase (e.g., LogbookChecker.tsx)
    - Utilities: camelCase (e.g., calculateDistance.ts)
    - Client components imported by servers: kebab-case (e.g., header-button.tsx)
    - Types/Interfaces: PascalCase (e.g., GeocodeResult)
    - Constants: UPPER_SNAKE_CASE (e.g., MAX_DISTANCE_KM)
  
  imports_exports:
    - Use named exports over default exports for better refactoring
    - Create index.ts files for cleaner imports from feature folders
    - Keep imports organized and remove unused imports

## Git & Version Control

git:
  commits:
    - Write clear, descriptive commit messages
    - Use conventional commits format: feat:, fix:, docs:, style:, refactor:, test:, chore:
    - Keep commits focused on a single change
  
  branches:
    - Never force push to main/master
    - Use descriptive branch names
    - Delete branches after merging
  
  hooks:
    - Never skip git hooks (--no-verify) unless absolutely necessary
    - Always run linting and type checking before committing

## Documentation

documentation:
  code_comments:
    - Write comments for complex logic, not obvious code
    - Use JSDoc comments for public functions and components
    - Explain "why" not "what" in comments
  
  readme:
    - Keep README up to date with setup instructions
    - Document all environment variables
    - Include examples for common use cases
  
  types:
    - Well-named types serve as documentation
    - Add comments to explain non-obvious type constraints

## Testing (Future)

testing:
  approach:
    - Write tests for critical business logic
    - Test user interactions, not implementation details
    - Use React Testing Library for component tests
    - Mock external API calls in tests

## Language & Localization

language:
  spelling:
    - Use Australian English spelling throughout the codebase
    - Examples: "travelling" not "traveling", "colour" not "color"
    - Use Australian terminology (e.g., "logbook" not "log book")
  
  formatting:
    - Use Australian date formats (DD/MM/YYYY)
    - Use metric units (km, not miles)
    - Use Australian address formats

## Project-Specific Rules

project_specific:
  nhvr_regulations:
    - Logbook required when travelling more than 100km from base
    - Base this on maximum distance from base along the driving route, not just straight-line distance to destination
    - Always include disclaimers that this tool is for reference only
  
  mapbox:
    - Always set preserveDrawingBuffer: true on map instances (required for PDF/print capture)
    - Store map instances properly for external access when needed
    - Reset map to original bounds before PDF capture
  
  user_data:
    - Store recent searches in localStorage only (no server-side storage yet)
    - Keep URL parameters shareable and bookmarkable
    - Never store sensitive information in URLs or localStorage

  popovers:
    architecture:
      - ALL popovers must use the DraggablePopover base component (app/(dashboard)/dashboard/components/popovers/draggable-popover.tsx)
      - DraggablePopover provides: dragging, collapsing, title editing, consistent styling, and close button
      - Popover state managed centrally in useUIStore (app/(dashboard)/dashboard/hooks/use-ui-store.ts)
      - Never create standalone floating UI components - always extend DraggablePopover
    
    state_management:
      - Add popover state to useUIStore with structure: { visible: boolean, x: number, y: number, collapsed?: boolean }
      - Create setter function (e.g., setAlignPopover, setPalletEditPopover) in useUIStore
      - Setter must implement smart positioning logic to avoid overlaps with other visible popovers
      - Store position state so manual user repositioning is preserved across show/hide
    
    smart_positioning:
      - MANDATORY: All new popovers must implement smart positioning in their setter function
      - When opening (visible: true), check for overlaps with ALL currently visible popovers
      - Include in overlap detection: stackable popovers, compliance, addPallet, palletEdit, align, etc.
      - Smart positioning algorithm:
        1. Collect all visible popovers with their x, y, and height
        2. Check if current position overlaps with any visible popover
        3. If overlap detected, place to the right of rightmost popover
        4. If no room on right (would go off screen), place below all popovers
        5. Validate position is within screen boundaries
      - Use constants: POPOVER_WIDTH (320), POPOVER_SPACING (20), COLLAPSED_POPOVER_HEIGHT (56)
      - When user manually drags popover, respect that position on next open (unless overlaps)
      - See setPalletEditPopover and setAlignPopover in use-ui-store.ts as reference implementations
    
    creating_new_popovers:
      - Create new popover component in app/(dashboard)/dashboard/components/popovers/
      - Import and use DraggablePopover as wrapper
      - Add state to UIState interface in use-ui-store.ts
      - Add default state in useUIStore create function
      - Implement setter with smart positioning (copy pattern from setAlignPopover)
      - Pass handlers from parent component (usually load-calculator.tsx)
      - Render conditionally based on visible state: {popover.visible && <YourPopover ... />}
    
    popover_props:
      - position: { x: number; y: number } - current position
      - onPositionChange: (pos: { x: number; y: number }) => void - update position in store
      - onClose?: () => void - set visible to false in store
      - collapsed?: boolean - current collapsed state
      - onCollapsedChange?: (collapsed: boolean) => void - update collapsed in store
      - Additional props specific to popover functionality
    
    styling:
      - Use consistent dark theme: bg-gray-800, border-gray-700, text-gray-300
      - Buttons: hover:bg-gray-700, text-gray-300
      - Disabled state: opacity-50, cursor-not-allowed
      - Use shadcn/ui Button component with variant="ghost" for popover actions
      - Min width around 280-320px depending on content
      - Use space-y-4 for section spacing, space-y-2 for item spacing
    
    examples:
      - PalletEditPopover: Edit single or multiple pallets, shows different UI for multi-edit
      - AlignPopover: Groups alignment, distribution, and packing tools like Illustrator
      - AddPalletPopover: Create new pallets with custom dimensions
      - BodyConfigPopover: Configure truck body dimensions and wall thickness
      - Pattern: Specialized popovers for specific tasks, opened from toolbar or canvas interactions

## Stripe & Subscriptions

stripe:
  data_fetching:
    - ALWAYS fetch subscription status and calculation history in Server Components (page.tsx)
    - NEVER fetch subscription data in client components - pass as props instead
    - Use Server Actions (getSubscriptionStatus, getCalculationHistory) only in Server Components
    - Pass subscription status (isPro) as props from page.tsx to client components
    - Use revalidatePath() after mutations to ensure fresh data on next render
    - Use React cache() for getSubscriptionStatus() and getCachedUser() to deduplicate queries
    - Wrap subscription data fetching in Suspense boundaries with skeleton loaders
  
  server_components:
    - Page components (page.tsx) should be async Server Components
    - Fetch all data at the page level (page.tsx) before rendering client components
    - Server Actions should only be called from Server Components for data fetching
    - Pass fetched data as props to client components - never fetch in client components
    - Extract data-fetching logic into separate server components wrapped in Suspense
    - Keep static page structure (titles, headers) outside Suspense for immediate rendering
    - Pattern: Static content renders immediately, dynamic content loads progressively via Suspense
    - For protected routes: Use getCachedUser() at page level, redirect if unauthorized (follows Supabase/Next.js best practices)
    - For public routes: No auth check, but can still fetch subscription status for feature gating
  
  mutations:
    - Client components can call Server Actions directly for mutations
    - Server Actions are designed to be called from client components (they have "use server" directive)
    - This is simpler and more type-safe than using API routes
    - Pattern: Server Components fetch data, Client Components call Server Actions for mutations
  
  feature_gating:
    - Gate features by passing isPro prop from Server Components (page.tsx)
    - Show upgrade prompts when free users try to access Pro features
    - Disable Pro features for free users with clear messaging
    - ALL Pro features MUST call validation Server Actions before executing:
      * Multiple Stops: call validateMultipleStops() before addStop()
      * CSV Import: call validateCSVImport() before processing CSV
      * PDF Export: call validatePDFExport() before generating PDF
    - Validation pattern for client components:
      ```typescript
      const handleFeature = async () => {
        const validation = await validateFeature()
        if (!validation.success) {
          toast.error(validation.error)
          return
        }
        // Feature logic here
      }
      ```
  
  calculation_history:
    - Only save calculation history for Pro users
    - Silently fail history saving - don't block UI if it fails
    - Use revalidatePath() after saving/deleting calculations
  
  security:
    - MANDATORY: All Pro features must have server-side validation before use
    - Three layers of security (defense in depth):
      1. Client-side checks (isPro prop) - UX only, NOT security
      2. Server Actions validation - validate subscription BEFORE executing feature
      3. Database RLS policies - enforce subscription at database level (for persisted data)
    - Pattern for client-side Pro features (CSV, PDF, Multiple Stops):
      * Client component calls validation Server Action
      * If validation passes, client-side processing proceeds
      * If validation fails, show error and return
    - Pattern for server-persisted Pro features (History, Recent Searches):
      * Client component calls Server Action
      * Server Action validates subscription status
      * Database RLS policy provides final enforcement
    - ALWAYS validate Pro subscription status server-side in Server Actions
    - Never trust client-side data - validate everything on the server
    - Verify user owns the data they're trying to access/modify
    - RLS policies check subscription_status in users table before allowing operations
    - See STRIPE_SECURITY.md for detailed security model
  
  ads:
    - Ad display is controlled by isPro prop from Server Component
    - Server Component (page.tsx) calls getSubscriptionStatus() which queries database
    - Ad components only rendered server-side if user is not Pro
    - User cannot bypass this - isPro comes from server-side database query
    - No RLS needed - ads are 3rd-party JavaScript, not database operations
    - Security: Server decides whether to include ad code in HTML, not client
  
  webhooks:
    - Handle all Stripe webhook events in /api/stripe/webhook route
    - Update user subscription status in Supabase on subscription events
    - Use metadata to link Stripe subscriptions to Supabase users

